= enterprise-script-service

Then enterprise script service (aka ESS) is a thin ruby API layer that spawns a process, the `enterprise_script_engine`, to execute some random ruby script. 

The `enterprise_script_engine` executable, ingests the input from `stdin` as a msgpack encoded payload; then spawns a mruby-engine; uses seccomp to sandbox itself; feeds `library`, `input` and finally the ruby scripts into the engine; and finally returns the output as a msgpack encoded payload to `stdout` and finally exits...

== Data format

=== Input

The input is expected to be a msgpack `MAP` with three keys (Symbol): `library`, `sources`, `input`:
 
 - `library`: a msgpack `BIN` set of mruby instructions that will be fed directly to the `mruby-engine`
 - `input`: a msgpack formated payload for the `sources` to digest
 - `sources`: a msgpack `ARRAY` of `ARRAY` with two elements each (tuples): `path`, `source`; the actual code to be executed by the mruby-engine
 
=== Output

The output is msgpack encoded as well, it is streamed to the consuming end though. Streamed items can be of different types.
Each element streamed is in the format of an `ARRAY` of two elements, where the first is a `Symbol` describing the element type:

 * `measurement`: a msgpack `ARRAY` of two elements: `Symbol` describing the measurement and a `INT64` with the value in Âµs.
 * `output`: a msgpack `MAP` with two entries (key are symbols): 
 ** `extracted` with whatever the script put in `@output`, msgpack encoded; and 
 ** `stdout` with a `STRING` with whatever the script printed to "stdout".
 * `stat`: with a `MAP` keyed with symbols to their `INT64` values
 
== Errors

When the ESS fails to serve a request, it communicates the error back to the caller by returning a non-zero status code.
It can also report data about the error, in certain cases, over the pipe. In does so in returning a tuple, as an `ARRAY` with the type being the symbol `error` and the payload being a `MAP`. The content of the map will vary, but it always will have a `__type` symbol key that defines the other keys.

== Build

[source]
----
$> ./bin/rake mrproper <1>
$> ./bin/rake <2>
----
<1> Cleans the whole build, useful when switching from one OS to another, so libs get properly rebuild
<2> Effectively runs targer `spec` which will build all libs, the ESS and native tests; then runs all tests (native and ruby)

== Using it

[source, ruby]
----
result = EnterpriseScriptService.run(
  input: {result: [26803196617, 0.475]}, # <1>
  sources: [
    ["stdout", "@stdout_buffer = 'hello'"],
    ["foo", "@output = @input[:result]"], # <2>
  ],
  timeout: 1000, # <3>
)
expect(result.success?).to be(true)
expect(result.output).to eq([26803196617, 0.475])
expect(result.stdout).to eq("hello")
----
<1> invokes the ESS, with a map as the `input` (available as `@input` in the sources)
<2> two "scripts" to be executed, one sets the `@stdout_buffer` to a value, the second puts the value associated to the key `:result` of the map used passed in in <1>
<3> give the ESS a 1000 second time quota to spawn, init, inject, eval and finally output the result back.

=== Turning off generational garbage collection

In some cases, you may want to run a script in an mruby environment with the generational garbage collector turned off. To do that, you can run:

[source, ruby]
----
result = EnterpriseScriptService.run(
  input: {result: [26803196617, 0.475]},
  sources: [
    ["stdout", "@stdout_buffer = 'hello'"],
    ["foo", "@output = @input[:result]"],
  ],
  instructions: nil,
  timeout: 10.0,
  instruction_quota: 100000,
  instruction_quota_start: 1,
  memory_quota: 8 << 20,
  generational_gc: false
)
----

Take note of the last argument of `generational_gc: false`.

== Where are things?

=== C++ sources

Consists of our code base, plus `seccomp` and `msgpack` libraries, as well as the `mruby` stuff. All in `ext/enterprise_script_service`
 
 NOTE: lib `seccomp` is omited on Darwin
 
==== Tests

Use googletest and are in `tests/`, which also includes the Google Test library

=== Ruby layer

Is in `lib\`;

==== Tests

Are all in `spec/`

== Other useful things

 - There is a `CMakeLists.txt` that's mainly there for CLion support, we don't use cmake to build any of this;
 - You can use vagrant to bootstrap a VM to test under Linux while on Darwin; useful for `seccomp`

=== Vagrant

[source]
----
$ vagrant up
$ vagrant ssh
ubuntu@ubuntu-xenial:~$ cd /vagrant
ubuntu@ubuntu-xenial:/vagrant$ ./bin/rake mrproper spec
----


